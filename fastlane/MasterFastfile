# Updated for v2.108.0

# frozen_string_literal: true

# Resources
# TODO: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/UI.md
# TODO: https://docs.fastlane.tools/advanced/#environment-variables
# TODO: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Appfile.md

fastlane_require 'dotenv/load'

default_platform :ios

platform :ios do
  # ========== #
  #   Global   #
  # ========== #

  before_all do
    setup_environment
  end

  error do |_lane, exception|
    alert(message: exception.message, success: false)
  end

  # ========= #
  #   Enums   #
  # ========= #

  module BuildHost
    LOCAL = 'local'
    BITRISE = 'bitrise'
    CIRCLE_CI = 'circle_ci'
    JENKINS = 'jenkins'
  end

  module ProjectType
    APP = 'app'
    POD = 'pod'
  end

  # ============== #
  #   Properties   #
  # ============== #

  # Build Properties

  def build_host
    if IS_LOCAL
      BuildHost::LOCAL
    elsif ENV.key?('BITRISE_IO')
      BuildHost::BITRISE
    elsif ENV.key?('CIRCLE_CI')
      BuildHost::CIRCLE_CI
    elsif ENV.key?('JENKINS_URL')
      BuildHost::JENKINS
    end
  end

  # The prefix prepended to the build tag on version bump
  def build_tag_prefix
    'builds/b'
  end

  def project_type
    env_project_type = ENV['SH_PROJECT_TYPE']

    # if SH_PROJECT_TYPE is nil, try to auto-detect the return 'pod' if it has a podspec and 'app' if it does not
    if env_project_type.nil?
      if ENV.key?('SH_PODSPEC')
        return ProjectType::POD
      else
        return ProjectType::APP
      end
    end

    # otherwise, return the SH_PROJECT_TYPE if it's a valid project type
    case env_project_type.downcase
    when ProjectType::APP
      return ProjectType::APP
    when ProjectType::POD
      return ProjectType::POD
    else
      UI.user_error!("Invalid project type: #{env_project_type}")
    end
  end

  def development_branch?
    current_branch = git_branch

    if ENV.key?('SH_DEVELOPMENT_BRANCH')
      sh_development_branch = ENV['SH_DEVELOPMENT_BRANCH']
      current_branch == sh_development_branch || current_branch == "origin/#{sh_development_branch}"
    elsif
      current_branch == 'develop' || current_branch == 'origin/develop'
    end
  end

  # IPA Properties

  def build_number
    get_ipa_info_plist_value(ipa: ipa_file, key: 'CFBundleVersion')
  end

  def bundle_identifier
    get_ipa_info_plist_value(ipa: ipa_file, key: 'CFBundleIdentifier')
  end

  def bundle_name
    bundle_identifier
  end

  def bundle_version
    get_ipa_info_plist_value(ipa: ipa_file, key: 'CFBundleShortVersionString')
  end

  def full_version
    "v#{bundle_version}b#{build_number}"
  end

  # File Properties

  def output_directory
    case build_host
    when BuildHost::BITRISE
      ENV['BITRISE_DEPLOY_DIR']
    when BuildHost::LOCAL
      "./output/#{ENV['SH_APP_NAME']}/#{ENV['SH_SCHEME']}"
    else
      './output'
    end
  end

  def dsym_file
    lane_context[SharedValues::DSYM_OUTPUT_PATH] || "#{output_directory}/#{ENV['SH_APP_NAME']}.app.dSYM.zip"
  end

  def ipa_file
    lane_context[SharedValues::IPA_OUTPUT_PATH] || "#{output_directory}/#{ENV['SH_APP_NAME']}.ipa"
  end

  # Slack Properties

  def default_payload
    payload = {
      'Build Date' => Time.new.to_s,
      'Build Host' => build_host
    }

    payload['Build Number'] = !ENV['BITRISE_BUILD_NUMBER'].nil? ? ENV['BITRISE_BUILD_NUMBER'] : 1
    payload['Version'] = lane_context[SharedValues::VERSION_NUMBER] unless lane_context[SharedValues::VERSION_NUMBER].nil?
    payload['HockeyApp URL'] = lane_context[SharedValues::HOCKEY_DOWNLOAD_LINK] unless lane_context[SharedValues::HOCKEY_DOWNLOAD_LINK].nil?
    payload['Bitrise URL'] = ENV['BITRISE_BUILD_URL'] unless ENV['BITRISE_BUILD_URL'].nil?

    payload
  end

  # Hockey Properties

  # get the hockey release_type from the SH_BUILD_TYPE
  def get_hockey_release_type_from_build_type(build_type)
    case build_type
    when 'adhoc'
      '0'
    when 'appstore'
      '1'
    when 'development'
      '0'
    when 'enterprise'
      '3'
    end
  end

  # Gym Properties

  # get the gym export_method from the SH_BUILD_TYPE, which is aligned with the match match_type variable
  def get_export_method_from_build_type(build_type)
    case build_type
    when 'adhoc'
      'ad-hoc'
    when 'appstore'
      'app-store'
    else
      build_type
    end
  end

  # ============= #
  #   Constants   #
  # ============= #

  IS_LOCAL = !is_ci
  PROJECT_TYPE = project_type

  # ============= #
  #   Preparing   #
  # ============= #

  desc 'Registers the devices (if possible), then checks and installs dependencies.'
  lane :prepare do
    check_dependencies
  end

  desc 'Registers devices on the Apple Developer Portal.'
  lane :register do
    next unless ENV.key?('FL_REGISTER_DEVICES_FILE')

    register_devices
  end

  desc 'Checks various dependencies and installs or updates them accordingly. (Ruby Gems, Fastlane, Cocoapods, Xcode)'
  private_lane :check_dependencies do
    if IS_LOCAL
      bundle_install
      update_fastlane
    end

    cocoapods(
      try_repo_update_on_error: true,
    )

    xcversion
  end

  private_lane :load_dotenv do
    if IS_LOCAL
      # .env.local should load automatically, but it's not working, so we're using the workaround of loading it manually
      Dotenv.load '.env.local'
    end

    if ENV.key?('DOTENV_ENVIRONMENT')
      environment = ENV['DOTENV_ENVIRONMENT']
      Dotenv.load ".env.#{environment}"
    end

    Dotenv.load '.env'
  end

  desc 'Sets various properties for the environment that will be used in multiple lanes. Should be run before any lane.'
  private_lane :setup_environment do
    load_dotenv
    populate_env_vars

    # if we're local, print environment variables
    sh 'env' if IS_LOCAL

    unless IS_LOCAL
      # hide the Fastlane changelog if we're on CI
      ENV['FASTLANE_HIDE_CHANGELOG'] = 'true'
    end
  end

  # ================================ #
  #   Codesigning and Provisioning   #
  # ================================ #

  desc 'Syncs codesigning certificates and provisioning profiles via Fastlane Match. (App only)'
  lane :certify do |options|
    assert_project_type(ProjectType::APP)

    force = !options[:force].nil? ? options[:force] : false
    readonly = !options[:readonly].nil? ? options[:readonly] : false

    match(
      force: force,
      force_for_new_devices: true,
      readonly: readonly,
    )
  end

  desc 'Syncs certificates for Apple Push Services. (App only)'
  lane :certify_aps do |options|
    assert_project_type(ProjectType::APP)

    force = !options[:force].nil? ? options[:force] : false

    name = if ENV['PEM_DEVELOPMENT'] == 'true'
             'aps_development'
           else
             'aps'
           end

    pem(
      force: force,
      generate_p12: true,
      output_path: 'aps',
      pem_name: "#{ENV['SH_APP_NAME']}_#{name}_#{Date.today.year}_#{Date.today.month}_#{Date.today.day}",
    )
  end

  # ============ #
  #   Building   #
  # ============ #

  desc 'Builds the project.'
  lane :build do
    # if IS_LOCAL
    #   ensure_xcode_version
    # end

    update_build_number

    gym(
      clean: true,
      include_symbols: true,
      output_directory: output_directory,
    )

    ENV['SCAN_TEST_WITHOUT_BUILDING'] = 'true'
    ENV['SCAN_DERIVED_DATA_PATH'] = ENV['GYM_DERIVED_DATA_PATH']
  end

  lane :update_build_number do
    assert_project_type(ProjectType::APP)

    # don't update a build number if we're running locally
    next if IS_LOCAL

    # only update a build number if there is a Bitrise build number available
    next unless ENV.key?('BITRISE_BUILD_NUMBER')

    build_number = ENV['BITRISE_BUILD_NUMBER']

    # set the build number to the Bitrise build number
    increment_build_number(
      build_number: build_number,
    )
  end

  # ======================= #
  #   Testing and Linting   #
  # ======================= #

  desc 'Runs unit tests and outputs results in JUnit format.'
  lane :test do
    scan(
      # clean: IS_LOCAL,
      code_coverage: true,
      devices: ['iPhone 8'],
      output_directory: output_directory,
      output_files: 'test_report.html,test_report.xml',
      output_types: 'html,junit',
      # skip_build: true,
      skip_slack: IS_LOCAL,
    )
  end

  lane :run_danger do |options|
    next if options[:skip_danger]

    # we do this due to a Bitrise bug, which is being addressed by their team
    if !IS_LOCAL && ENV.key?('GIT_REPOSITORY_URL')
      git_repository_url = ENV['GIT_REPOSITORY_URL']
      ENV['GIT_REPOSITORY_URL'] = git_repository_url.sub('https://', '')
    end

    # we can only run danger locally if we pass in a pull request ID
    if IS_LOCAL && options[:pr]
      pull_request = "https://github.com/#{ENV['SH_REPO']}/pull/#{options[:pr]}"
    elsif IS_LOCAL && options[:pr].nil?
      UI.user_error!('Unable run danger locally without specifying a pull request ID! Use the pr: lane parameter to do so.')
      next
    elsif !IS_LOCAL && options[:pr]
      UI.user_error!('Pull request ID can only be specified when running danger locally.')
    end

    danger(
      github_api_token: ENV['GITHUB_ACCESS_TOKEN'],
      new_comment: true,
      pr: pull_request,
      verbose: true,
    )
  end

  # =================== #
  #   Deploying (App)   #
  # =================== #

  # TODO: Deploy to HockeyApp
  # TODO: Deploy to iTunes Connect (?)
  # TODO: Upload dSYMs to Crashlytics
  # TODO: Refresh dSYMS from App Store to Crashlytics

  desc 'Deploys the app. (App only)'
  lane :app_deploy do
    assert_project_type(ProjectType::APP)

    if ENV['SH_BUILD_TYPE'] == 'appstore'
      app_deploy_to_testflight
    elsif
      app_deploy_to_hockeyapp
    end

    app_upload_symbols

    alert(
      message: 'App deployed and stuff!',
      success: true,
    )

    rocket
  end

  desc 'Deploys the app to HockeyApp. (App only)'
  lane :app_deploy_to_hockeyapp do
    assert_project_type(ProjectType::APP)

    build_server_url = ENV['BITRISE_BUILD_URL'] if build_host == BuildHost::BITRISE

    hockey(
      build_server_url: build_server_url,
      dsym: dsym_file,
      ipa: ipa_file,
      notes: 'Uploaded by Fastlane.',
      strategy: 'replace',
    )
  end

  desc 'Deploys the app to TestFlight. (App only)'
  lane :app_deploy_to_testflight do
    assert_project_type(ProjectType::APP)

    pilot(
      distribute_external: false,
      skip_submission: true,
      skip_waiting_for_build_processing: true,
    )
  end

  desc 'Uploads symbols to crashlytics and sentry. (App only)'
  lane :app_upload_symbols do
    assert_project_type(ProjectType::APP)

    if ENV.key?('CRASHLYTICS_API_TOKEN')
      upload_symbols_to_crashlytics(
        dsym_path: dsym_file,
      )
    end

    next unless ENV.key?('SENTRY_PROJECT_SLUG')

    begin
      sh('cd .. && scripts/install_sentry_cli.sh')

      sentry_upload_dsym(
        auth_token: '7c4f6d2459244cffaeda48d834aacd83aa9caba795384a3eb8c1947431992015',
        org_slug: 'spotherocom',
        project_slug: ENV['SENTRY_PROJECT_SLUG'],
        dsym_path: dsym_file,
        # info_plist: '...' # optional, sentry-cli tries to find the correct plist by itself
      )
    rescue StandardError => ex
      alert(message: ex.message, success: false)
    end
  end

  # desc "Downloads dSYM files from Apple iTunes Connect and uploads to Crashlytics."
  # lane :refresh_dsyms do
  #   download_dsyms                  # Download dSYM files from iTC
  #   upload_symbols_to_crashlytics   # Upload them to Crashlytics
  #   clean_build_artifacts           # Delete the local dSYM files
  # end

  # desc "Gets the folder name for the artifacts based on the current branch and app."
  # private_lane :get_folder_name do |options|
  #   branch = git_branch

  #   if git_branch.include?("develop")
  #     return "develop"
  #   end

  #   if git_branch.include?("master")
  #     return "master"
  #   end

  #   if git_branch.include?("feature")
  #     return branch
  #   end

  #   return folder

  # end

  # =================== #
  #   Deploying (Pod)   #
  # =================== #

  desc 'Bumps or sets the podspec and project version. (Pod only) (Local only)'
  lane :pod_bump do |options|
    assert_project_type(ProjectType::POD)
    assert_local_only

    # get options
    bump_type = options[:bump_type] || ENV['SH_POD_BUMP_TYPE']
    version = options[:version] || ENV['SH_POD_VERSION']

    # don't proceed without a clean repo
    ensure_git_status_clean_or_commit

    # if version is nil, get version from the bump type
    if version.nil?
      # if we don't have a bump type, select one
      bump_type ||= select_bump_type

      # bump the podspec and get the new version number
      version = version_bump_podspec(bump_type: bump_type)
    else
      # if trying to set to a version that already exists, throw an error
      UI.user_error!("Unable to bump pod, v#{version} already exists!") if git_tag_exists(tag: "v#{version}")

      # set the version number of the podspec
      version_bump_podspec(version_number: version)
    end

    # set the version number of the xcode project
    increment_version_number(version_number: version)

    # create the message for commits and notifications
    message = options[:message] || "Updating version number to #{version}."

    # commit the version number bump
    commit(message: message)

    # ensure the commit worked
    ensure_git_status_clean
  end

  lane :pod_deploy do |options|
    assert_project_type(ProjectType::POD)

    allow_warnings = options[:allow_warnings].nil? ? true : options[:allow_warnings]
    repo = options[:repo] || ENV['SH_PODSPEC_REPO']
    verbose = options[:verbose].nil? ? false : options[:verbose]

    # validate that we have set a podspec repo and block from defaulting to trunk
    UI.user_error!('No podspec repo set! To push to trunk, you must explicitly set repo to trunk.') if repo.nil?

    # get the version out of the podspec
    version = options[:version] || version_get_podspec

    # validate that we have a version
    UI.user_error!('No version found.') if version.nil?

    # create tag out of the version
    tag = "v#{version}"

    # create and push new version tag to remote if it doesn't already exist
    unless git_tag_exists(tag: tag)
      add_git_tag(tag: tag)
      push_git_tags
    end

    # push the pod!
    pod_push(
      allow_warnings: allow_warnings,
      path: ENV['SH_PODSPEC'],
      repo: repo,
      # swift_version: ENV['SH_SWIFT_VERSION'],
      verbose: verbose,
    )

    # if we have a GitHub PR API token, start a pull request
    if ENV['GITHUB_PULL_REQUEST_API_TOKEN']
      create_pull_request(
        title: "Release v#{version}",
      )

      message = "#{ENV['SH_APP_NAME']} v#{version} Deployed!"
    else
      message = "#{ENV['SH_APP_NAME']} v#{version} Deployed! Don't forget to create a pull request from develop to master."
    end

    alert(message: message, success: true)
  end

  desc 'Deploys the pod when a tag is pushed. (Pod only) (CI only)'
  lane :pod_deploy_on_tag do |options|
    assert_project_type(ProjectType::POD)
    assert_ci_only

    # add the SpotHero podspec repo
    add_spec_repo

    # get the tag that triggered this build
    tag = ENV['BITRISE_GIT_TAG']

    # get the podspec version
    version = version_get_podspec

    # if tag and version don't match, throw an error
    UI.user_error!("Tag #{tag} does not match podspec version #{version}.") unless tag == "v#{version}"

    options[:version] = version

    pod_deploy(options)
  end

  # ================= #
  #   Notifications   #
  # ================= #

  desc 'Displays a notification if local, sends a message to slack if remote.'
  private_lane :alert do |options|
    message = options[:message]

    # If there is no message, don't alert
    next unless message

    payload = options[:payload].nil? ? default_payload : options[:payload]
    success = options[:success].nil? ? false : options[:success]
    force_slack = options[:force_slack].nil? ? false : options[:force_slack]

    # If local, send local notification, otherwise send a slack message (unless force_slack = true)
    if IS_LOCAL && !force_slack
      notification(subtitle: 'Error', message: message)

      say message if options[:say]
    else
      slack(
        # default_payloads: [:git_author, :git_branch, :git_commit, :git_commit_hash],
        message: message,
        payload: payload,
        success: success,
      )
    end
  end

  # ============================== #
  #   Convenience Lanes (Shared)   #
  # ============================== #

  desc 'Adds the spec repo to the local cocoapods environment.'
  lane :add_spec_repo do |options|
    repo = options[:repo] || ENV['PODSPEC_REPO']
    repo_url = options[:repo_url] || ENV['PODSPEC_REPO_URL']

    sh "pod repo add #{repo} #{repo_url}"
  end

  desc 'Adds all files to a commit and gets a message from the terminal if none is provided, then pushes to remote. (Local only)'
  lane :commit do |options|
    UI.user_error!('This lane is only available locally.') unless IS_LOCAL

    message = options[:message]

    message ||= UI.input('What did you change? (Enter commit message.)')

    git_commit(path: '.', message: message)

    push_to_git_remote

    ensure_git_status_clean

    alert(message: 'Committed!')
  end

  private_lane :ensure_git_status_clean_or_commit do
    begin
      ensure_git_status_clean
    rescue StandardError
      UI.user_error!('Git status is not clean!') unless IS_LOCAL

      commit_message = UI.input('Current branch is not clean. You need to commit. Enter your commit message: ')
      commit(message: commit_message)
    end
  end

  desc 'Runs test and lints with danger.'
  desc 'If the project is a pod, it will also run the pod_lint lane.'
  lane :test_and_lint do |options|
    test
    run_danger(options)

    pod_lint if PROJECT_TYPE == ProjectType::POD
  end

  # ========================== #
  #   Convenience Lanes (App)  #
  # ========================== #

  desc 'Builds then deploys. (App only)'
  lane :app_build_and_deploy do |options|
    assert_project_type(ProjectType::APP)

    # register devices before we fetch or update provisioning profiles
    register

    # since we're building an app, we need to run match (fetch or update provisioning profiles)
    # this is so that it generates or refreshes a profile and automatically uses the same profile
    # when building the app (from calling gym)
    certify(options)

    build
    app_deploy
  end

  # ========================== #
  #   Convenience Lanes (Pod)  #
  # ========================== #

  desc 'Lints the pod library. (Pod only)'
  lane :pod_lint do |options|
    assert_project_type(ProjectType::POD)

    allow_warnings = !options[:allow_warnings].nil? ? options[:allow_warnings] : true
    verbose = !options[:verbose].nil? ? options[:verbose] : !IS_LOCAL

    # verify_pod_keys
    pod_lib_lint(allow_warnings: allow_warnings, verbose: verbose)
  end

  # =============================== #
  #   Convenience Methods (Shared)  #
  # =============================== #

  def assert_local_only
    UI.user_error!('This lane is only available locally!') unless IS_LOCAL
  end

  def assert_ci_only
    UI.user_error!('This lane is only available on CI!') if IS_LOCAL
  end

  def assert_build_host(required_build_host)
    UI.user_error!("This lane will only work for #{build_host} builds.") unless build_host == required_build_host
  end

  def assert_project_type(project_type)
    return if PROJECT_TYPE == project_type

    UI.user_error!("This lane is for '#{project_type}' projects, but the current project type is '#{PROJECT_TYPE}'.")
  end

  def get_build_setting(options = {})
    if options[:xcodeproj].nil?
      UI.error 'xcodeproj parameter must be provided'
      return nil
    end

    if options[:setting].nil?
      UI.error 'setting parameter must be provided'
      return nil
    end

    fastlane_require 'xcodeproj'

    project = Xcodeproj::Project.open("../#{options[:xcodeproj]}")

    config = if options[:configuration].nil?
               project.build_configurations.first
             else
               project.build_configurations.select { |t| t.name == options[:configuration] }.first
             end

    setting = config.build_settings[options[:setting]]

    setting
  end

  # populate other env vars with those loaded before app startup
  # TODO: Don't populate an env var that's already been set
  def populate_env_vars
    build_type = ENV['SH_BUILD_TYPE']
    config_folder = ENV['SH_CONFIG_FOLDER']

    # gym
    # TODO: Don't set GYM_EXPORT_OPTIONS only on build_type and config_folder availability, only HeroTech would use this
    # Maybe make SH_EXPORT_OPTIONS_FOLDER
    ENV['GYM_EXPORT_METHOD'] = get_export_method_from_build_type(build_type) # TODO: unless ENV.key?('GYM_EXPORT_METHOD')
    ENV['GYM_EXPORT_OPTIONS'] = "#{config_folder}/ExportOptions.#{build_type}.plist" unless build_type.nil? || config_folder.nil?
    ENV['GYM_SCHEME'] = ENV['SH_SCHEME']

    # hockey
    ENV['FL_HOCKEY_RELEASE_TYPE'] = get_hockey_release_type_from_build_type(build_type)

    # match
    ENV['MATCH_APP_IDENTIFIER'] = ENV['SH_APP_IDENTIFIER'] unless ENV.key?('MATCH_APP_IDENTIFIER')
    ENV['MATCH_TYPE'] = build_type

    # pem
    ENV['PEM_APP_IDENTIFIER'] = ENV['SH_APP_IDENTIFIER'] unless ENV.key?('PEM_APP_IDENTIFIER')

    ENV['PEM_DEVELOPMENT'] = build_type == 'development' ? 'true' : 'false'

    # scan
    ENV['SCAN_SCHEME'] = ENV['SH_SCHEME']

    # upload_symbols_to_crashlytics
    google_info_plist_filename = ENV['SH_GOOGLE_INFO_PLIST_FILENAME']
    ENV['GOOGLE_SERVICES_INFO_PLIST_PATH'] = "#{config_folder}/#{google_info_plist_filename}" unless google_info_plist_filename.nil? || config_folder.nil?
  end

  # def get_output_name options={}
  #   if options[:xcodeproj].nil?
  #     UI.error "xcodeproj parameter must be provided"
  #     return nil
  #   end

  #   build_number = get_build_number(xcodeproj: options[:xcodeproj])

  #   app_name = get_build_setting(
  #     xcodeproj: options[:xcodeproj],
  #     setting: "APPLICATION_BUNDLE_DISPLAY_NAME"
  #   )

  #   bundle_version = get_build_setting(
  #     xcodeproj: options[:xcodeproj],
  #     setting: "COMMON_APP_VERSION"
  #   )

  #   return "#{app_name}-#{bundle_version}-#{build_number}"
  # end

  # ============================ #
  #   Convenience Methods (Pod)  #
  # ============================ #

  def select_bump_type
    UI.user_error!('No version or bump type found.') unless IS_LOCAL
    UI.select('What type of update is this?', %w[major minor patch])
  end
end
